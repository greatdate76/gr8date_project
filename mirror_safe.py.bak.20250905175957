#!/usr/bin/env python3
import csv, hashlib, re, sys
from pathlib import Path
from urllib.parse import urlparse

PROFILE_COL = "profile_image"
ADDITIONAL_COL = "additional_images"
PRIVATE_COL = "private_images"
MULTI_SPLIT = re.compile(r'[;,]\s*')

def nonempty(s):
    return isinstance(s, str) and s.strip() and s.strip().lower() not in ["nan", "none"]

def fix_url(u: str) -> str:
    u = u.strip()
    if u.startswith('https:/') and not u.startswith('https://'):
        u = u.replace('https:/', 'https://', 1)
    if u.startswith('http:/') and not u.startswith('http://'):
        u = u.replace('http:/', 'http://', 1)
    return u

def rel_uploads_path(url: str):
    try:
        p = urlparse(url).path
    except Exception:
        return None
    m = re.search(r"/wp-content/uploads/(.+)$", p, re.IGNORECASE)
    return Path(m.group(1)) if m else None

def first_from(val):
    if not nonempty(val):
        return ""
    parts = [p for p in MULTI_SPLIT.split(val) if p.strip()]
    return parts[0].strip() if parts else ""

def unique_basename(uploads_root: Path, base: str):
    hits = list(uploads_root.rglob(base))
    return hits[0] if len(hits) == 1 else None

def map_one(url: str, uploads_root: Path):
    url = fix_url(url)
    rel = rel_uploads_path(url)
    if rel:
        p = uploads_root / rel
        if p.exists():
            return p
    base = Path(urlparse(url).path).name.split("?")[0].split("#")[0]
    if base:
        hit = unique_basename(uploads_root, base)
        if hit and hit.exists():
            return hit
    return None

def process_cell(cell_val, user_id, uploads_root: Path, media_root: Path):
    if not nonempty(cell_val):
        return ""
    out = []
    parts = [x.strip() for x in MULTI_SPLIT.split(str(cell_val)) if nonempty(x)]
    for raw in parts:
        src = map_one(raw, uploads_root)
        if not src:
            continue
        h = hashlib.sha1(str(src).encode("utf-8")).hexdigest()[:12]
        dest = (media_root / f"user_{user_id}" / f"{h}_{src.name}")
        dest.parent.mkdir(parents=True, exist_ok=True)
        if not dest.exists():
            dest.write_bytes(src.read_bytes())
        rel_out = Path("media") / dest.relative_to(media_root.parent)
        out.append(str(rel_out))
    # de-dup while preserving order
    seen, out2 = set(), []
    for p in out:
        if p not in seen:
            out2.append(p)
            seen.add(p)
    return ";".join(out2)

def main():
    if len(sys.argv) < 5:
        print("Usage: python mirror_safe.py <INPUT_CSV> <OUTPUT_CSV> <UPLOADS_ROOT> <MEDIA_ROOT>")
        sys.exit(1)
    in_csv, out_csv, uploads, media = map(lambda p: Path(p).expanduser(), sys.argv[1:5])

    import pandas as pd
    df = pd.read_csv(in_csv)

    cols = {c.lower(): c for c in df.columns}
    def get(name): return cols.get(name.lower())

    uid_col  = get("user_id") or get("id") or get("uid")
    prof_col = get(PROFILE_COL) or PROFILE_COL
    addl_col = get(ADDITIONAL_COL) or ADDITIONAL_COL
    priv_col = get(PRIVATE_COL) or PRIVATE_COL
    if not uid_col:
        raise SystemExit("CSV must have user_id/id/uid column.")
    if prof_col not in df.columns:
        df[prof_col] = ""

    # promote a first image if profile_image is blank
    for i, row in df.iterrows():
        if not nonempty(row.get(prof_col)):
            df.at[i, prof_col] = first_from(row.get(addl_col, "")) or first_from(row.get(priv_col, ""))

    uploads_root = uploads
    media_root   = media

    for col in [prof_col, addl_col, priv_col]:
        if col in df.columns:
            df[col] = [
                process_cell(row.get(col, ""), row[uid_col], uploads_root, media_root)
                for _, row in df.iterrows()
            ]

    out_csv.parent.mkdir(parents=True, exist_ok=True)
    df.to_csv(out_csv, index=False)
    print(f"Wrote: {out_csv}")

if __name__ == "__main__":
    main()
